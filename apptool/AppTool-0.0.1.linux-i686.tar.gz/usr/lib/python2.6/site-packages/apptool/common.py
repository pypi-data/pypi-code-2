#!/usr/bin/env python
#
# AppTool
# Copyright (C) 2010  Nathan Forbes
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import re
import sys
import zipfile
import subprocess

import cli

def mainWorkDir():
  return os.path.join(os.path.expanduser('~'), 'AppTool')

class ZipUtil(object):
  def __init__(self, zipwrite=False, zipextract=False, zipname=None):
    self.zipwrite = zipwrite
    self.zipextract = zipextract
    self.zipname = zipname
    self.appdir = os.path.join(mainWorkDir(), 'Apps')
  def _zipWrite(self):
    try:
      z = zipfile.ZipFile(self.zipname, 'w', zipfile.ZIP_DEFLATED)
      for dp, dn, fn in os.walk(self.appdir):
        for f in fn:
          abs = os.path.join(dp, f)
          arc = abs[len(self.appdir)+1:]
          z.write(abs, arc)
    except (IOError, OSError), e:
      cli.warning(str(e))
    finally:
      z.close()
  def _zipExtract(self):
    try:
      e = zipfile.ZipFile(self.zipname, 'r')
      try:
        e.extractall()
      except (IOError, OSError), e:
        cli.warning(str(e))
    finally:
      e.close()
  def work(self):
    if self.zipwrite:
      return self._zipWrite()
    if self.zipextract:
      return self._zipExtract()

##
# ADB Interface
##
def adbPath():
  path = os.getenv('PATH').split(os.pathsep)
  if os.name == 'nt':
    adb = 'adb.exe'
  else:
    adb = 'adb'
  adbpath = None
  if '' in path:
    path.remove('')
  for p in path:
    if adb in os.listdir(p):
      adbpath = os.path.join(p, adb)
      break
  if not adbpath:
    return cli.error("`%s' not found anywhere in `PATH'" % adb)
  return adbpath

def device():
  adb = adbPath()
  d = subprocess.Popen(
                [adb, 'devices'],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
          )
  d = list(d.communicate())
  if '' in d:
    d.remove('')
  if len(d) > 1:
    return cli.error("Too many devices connected at once")
  if not re.findall(r"[0-9]", d[0]):
    return cli.error("No device connected at this time")
  return True

def adbPull(dest):
  adb = adbPath()
  if device():
    cmd_one = subprocess.Popen(
                      [adb, 'pull', '/data/app', os.path.join(dest, 'app')],
                      stdin=subprocess.PIPE,
                      stderr=subprocess.PIPE
              )
    cmd_one.communicate()
    cmd_two = subprocess.Popen(
                      [adb, 'pull', '/data/app-private', os.path.join(dest, 'app-private')],
                      stdin=subprocess.PIPE,
                      stderr=subprocess.PIPE
              )
    cmd_two.communicate()

def adbInstall(src):
  adb = adbPath()
  if device():
    cmd = subprocess.Popen([adb, 'install', src])
    cmd.communicate()
